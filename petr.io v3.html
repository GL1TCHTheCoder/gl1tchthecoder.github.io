<!doctype html><html><head></head><body><!DOCTYPE html>
<html>

<head>
	<title>PETR.IO</title>
	<meta charset="UTF-8">
	<style>
		.lBrd {
	                position: fixed;
			left: 2%;
			top: 5%;
			height: 80%;
		        width: 25%;
			font-size: 20px;
			border: solid white 4px;
			background-color: black;
		}
		html,
		body {
			height: 100%;
			margin: 0;
		}

		.trying {
			color: white;
			position: fixed;
			top: 8%;
			left: 35%;
			font-family: monospace;
			font-size: 18px;
		}

		.f {
			top: 10px;
			left: 10px;
			position: fixed;
			width: 12%;
			height: 10%;
			background-color: rgba(100, 100, 100, 0.5);
			border-radius: 5px;
			color: white;
			font-size: 18px;
			text-align: center;
		}

        .g {
			top: 10px;
			right: 10px;
			position: fixed;
			width: 12%;
			height: 10%;
			background-color: rgba(100, 100, 100, 0.5);
			border-radius: 5px;
			color: white;
			font-size: 18px;
			text-align: center;
		}
		.score {
			color: white;
			position: fixed;
			top: 0%;
			left: 35%;
			font-family: monospace;
			font-size: 18px;
		}

		body {
			background: black;
			display: flex;
			align-items: center;
			justify-content: center;
		}

		canvas {
			border: 1px solid white;
			height: 70%;
			position: fixed;
			top: 20%;
		}

		.controls {
			position: fixed;
			bottom: 10px;
			left: 50%;
			transform: translateX(-50%);
			display: flex;
			justify-content: space-around;
			width: 90%;
		}

		.controls button {
			width: 50px;
			height: 50px;
			background-color: rgba(100, 100, 100, 0.5);
			border: none;
			color: white;
			font-size: 18px;
			border-radius: 5px;
		}
	</style>
</head>

<body>
	<canvas width="320" height="640" id="game"></canvas>
	<p id="lines" class="trying">lines: 0</p>
	<p id="score" class="score">score: 0</p>
	<button onclick="save()" class="f">Save</button>
    <button onclick="load()" class="g">Load</button>
        <table style="position: fixed;
              left: 2%;
              top: 25%;
              height: 80%;
              width: 25%;
              font-size: 20px;
		color: black;
              border: solid white 4px;
              background-color: rgba(255, 255, 255, 1);">
  <thead>
    <tr>
      <th scope="col">Person</th>
      <th scope="col">Score</th>
      <th scope="col">Place</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>GL1TCHYT</td>
      <td>1,293,564</td>
      <td>1.</td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td>2.</td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td>3.</td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td>4.</td>
    </tr>
  </tbody>
</table>

	<div class="controls">
		<button id="left">←</button>
		<button id="rotate">↑</button> 
		<button id="down">↓</button>
		<button id="right">→</button>
		<button id="hardDrop">⇩</button>
	</div>
	<script>
		var lines = 0;
        var score = 0;
        var speed = 100;
        var ba = document.querySelector("p[id='lines']");
        var pa = document.querySelector("p[id='score']");
		var mus = new Audio("tetris_8bit.mp3")
		mus.play();
        // Save the game state
function save() {
    localStorage.setItem('tetrisGameState', JSON.stringify({
        'playfield': playfield,
        'lines': lines,
        'score': score
    }));
}

// Load the game state
function load() {
    const savedState = JSON.parse(localStorage.getItem('tetrisGameState'));
    if (savedState) {
        playfield = savedState.playfield;
        lines = savedState.lines;
        score = savedState.score;
        ba.innerText = "lines: " + lines;
        pa.innerText = "score: " + score;
    }
}

// Call these functions where necessary, such as after game over or on load

            
        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function generateSequence() {
            const sequence = ['I', 'J', 'L', 'O', 'S', 'T', 'Z'];
            while (sequence.length) {
                const rand = getRandomInt(0, sequence.length - 1);
                const name = sequence.splice(rand, 1)[0];
                tetrominoSequence.push(name);
            }
        }

        function getNextTetromino() {
            if (tetrominoSequence.length === 0) {
                generateSequence();
            }
            const name = tetrominoSequence.pop();
            const matrix = tetrominos[name];
            const col = playfield[0].length / 2 - Math.ceil(matrix[0].length / 2);
            const row = name === 'I' ? -1 : -2;
            return {
                name: name,
                matrix: matrix,
                row: row,
                col: col
            };
        }

        function rotate(matrix) {
            const N = matrix.length - 1;
            const result = matrix.map((row, i) =>
                row.map((val, j) => matrix[N - j][i])
            );
            return result;
        }

        function isValidMove(matrix, cellRow, cellCol) {
            for (let row = 0; row < matrix.length; row++) {
                for (let col = 0; col < matrix[row].length; col++) {
                    if (matrix[row][col] && (
                            cellCol + col < 0 ||
                            cellCol + col >= playfield[0].length ||
                            cellRow + row >= playfield.length ||
                            playfield[cellRow + row][cellCol + col])
                    ) {
                        return false;
                    }
                }
            }
            return true;
        }

        function placeTetromino() {
            for (let row = 0; row < tetromino.matrix.length; row++) {
                for (let col = 0; col < tetromino.matrix[row].length; col++) {
                    if (tetromino.matrix[row][col]) {
                        if (tetromino.row + row < 0) {
                            return showGameOver();
                        }
                        playfield[tetromino.row + row][tetromino.col + col] = tetromino.name;
                    }
                }
            }

            let clearedLines = 0;

            for (let row = playfield.length - 1; row >= 0;) {
                if (playfield[row].every(cell => !!cell)) {
                    for (let r = row; r >= 0; r--) {
                        for (let c = 0; c < playfield[r].length; c++) {
                            playfield[r][c] = playfield[r - 1][c];
                        }
                    }
                    clearedLines += 1;
                } else {
                    row--;
                }
            }

            lines += clearedLines;
            ba.innerText = "lines: " + lines;
            score += clearedLines * 100;
            pa.innerText = "score: " + score;

            tetromino = getNextTetromino();
        }

        function showGameOver() {
            cancelAnimationFrame(rAF);
            gameOver = true;
            context.fillStyle = 'black';
            context.globalAlpha = 0.75;
            context.fillRect(0, canvas.height / 2 - 30, canvas.width, 60);
            context.globalAlpha = 1;
            context.fillStyle = 'white';
            context.font = '36px monospace';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText('GAME OVER!', canvas.width / 2, canvas.height / 2);
        }

        const canvas = document.getElementById('game');
        const context = canvas.getContext('2d');
        const grid = 32;
        const tetrominoSequence = [];
        const playfield = [];

        for (let row = -2; row < 20; row++) {
            playfield[row] = [];
            for (let col = 0; col < 10; col++) {
                playfield[row][col] = 0;
            }
        }

        const tetrominos = {
            'I': [
                [0, 0, 0, 0],
                [1, 1, 1, 1],
                [0, 0, 0, 0],
                [0, 0, 0, 0]
            ],
            'J': [
                [1, 0, 0],
                [1, 1, 1],
                [0, 0, 0],
            ],
            'L': [
                [0, 0, 1],
                [1, 1, 1],
                [0, 0, 0],
            ],
            'O': [
                [1, 1],
                [1, 1],
            ],
            'S': [
                [0, 1, 1],
                [1, 1, 0],
                [0, 0, 0],
            ],
            'Z': [
                [1, 1, 0],
                [0, 1, 1],
                [0, 0, 0],
            ],
            'T': [
                [0, 1, 0],
                [1, 1, 1],
                [0, 0, 0],
            ]
        };

        const colors = {
            'I': 'cyan',
            'O': 'yellow',
            'T': 'purple',
            'S': 'green',
            'Z': 'red',
            'J': 'blue',
            'L': 'orange'
        };

        let count = 0;
        let tetromino = getNextTetromino();
        let rAF = null;
        let gameOver = false;

        function loop() {
            rAF = requestAnimationFrame(loop);
            context.clearRect(0, 0, canvas.width, canvas.height);

            for (let row = 0; row < 20; row++) {
                for (let col = 0; col < 10; col++) {
                    if (playfield[row][col]) {
                        const name = playfield[row][col];
                        context.fillStyle = colors[name];
                        context.fillRect(col * grid, row * grid, grid - 1, grid - 1);
                    }
                }
            }

            if (tetromino) {
                if (++count > speed) {
                    tetromino.row++;
                    count = 0;

                    if (!isValidMove(tetromino.matrix, tetromino.row, tetromino.col)) {
                        tetromino.row--;
                        placeTetromino();
                    }
                }

                context.fillStyle = colors[tetromino.name];

                for (let row = 0; row < tetromino.matrix.length; row++) {
                    for (let col = 0; col < tetromino.matrix[row].length; col++) {
                        if (tetromino.matrix[row][col]) {
                            context.fillRect((tetromino.col + col) * grid, (tetromino.row + row) * grid, grid - 1, grid - 1);
                        }
                    }
                }
            }
        }

        document.addEventListener('keydown', function (e) {
            if (gameOver) return;

            if (e.which === 37 || e.which === 39) {
                const col = e.which === 37 ? tetromino.col - 1 : tetromino.col + 1;
                if (isValidMove(tetromino.matrix, tetromino.row, col)) {
                    tetromino.col = col;
                }
            }

            if (e.which === 38) {
                const matrix = rotate(tetromino.matrix);
                if (isValidMove(matrix, tetromino.row, tetromino.col)) {
                    tetromino.matrix = matrix;
                }
            }

            if (e.which === 40) {
                const row = tetromino.row + 1;
                if (!isValidMove(tetromino.matrix, row, tetromino.col)) {
                    tetromino.row--;
                    placeTetromino();
                    return;
                }
                tetromino.row = row;
            }

            if (e.keyCode === 88) {
                while (isValidMove(tetromino.matrix, tetromino.row + 1, tetromino.col)) {
                    tetromino.row++;
                }
                placeTetromino();
            }

            if (e.keyCode === 90) {
                const matrix = rotate(tetromino.matrix);
                if (isValidMove(matrix, tetromino.row, tetromino.col)) {
                    tetromino.matrix = matrix;
                }
            }
	if (e.keyCode === 67) { // ASCII code for 'c'
    for (var i = 0; i < 3; i++) {
        const rotatedMatrix = rotate(tetromino.matrix);
        if (isValidMove(rotatedMatrix, tetromino.row, tetromino.col)) {
            tetromino.matrix = rotatedMatrix;
        } else {
            break; // Exit the loop if the rotation is not valid
        }
    }
}

        });

        document.getElementById('left').addEventListener('click', function () {
            const col = tetromino.col - 1;
            if (isValidMove(tetromino.matrix, tetromino.row, col)) {
                tetromino.col = col;
            }
        });

        document.getElementById('right').addEventListener('click', function () {
            const col = tetromino.col + 1;
            if (isValidMove(tetromino.matrix, tetromino.row, col)) {
                tetromino.col = col;
            }
        });

        document.getElementById('rotate').addEventListener('click', function () {
            const matrix = rotate(tetromino.matrix);
            if (isValidMove(matrix, tetromino.row, tetromino.col)) {
                tetromino.matrix = matrix;
            }
        });

        document.getElementById('down').addEventListener('click', function () {
            const row = tetromino.row + 1;
            if (!isValidMove(tetromino.matrix, row, tetromino.col)) {
                tetromino.row--;
                placeTetromino();
                return;
            }
            tetromino.row = row;
        });

        document.getElementById('hardDrop').addEventListener('click', function () {
            while (isValidMove(tetromino.matrix, tetromino.row + 1, tetromino.col)) {
                tetromino.row++;
            }
            placeTetromino();
        });

        rAF = requestAnimationFrame(loop);

        function a() {
            var e = document.documentElement;
            (e.requestFullscreen || e.mozRequestFullScreen || e.webkitRequestFullscreen || e.msRequestFullscreen).call(e);
        }

        let pr = prompt("Please enter a speed in frames", "100");
        if (pr != null) {
            speed = pr;
        }
	</script>
</body>

</html></body><html>
